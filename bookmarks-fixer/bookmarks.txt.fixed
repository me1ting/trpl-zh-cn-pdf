Rust 程序设计语言	1
前言	1
介绍	2
	谁会使用 Rust	2
		开发者团队	3
		学生	3
		公司	3
		开源开发者	3
		重视速度和稳定性的开发者	3
	本书是写给谁的	4
	如何阅读本书	4
	源代码	5
1. 入门指南	5
	1.1. 安装	6
		在 Linux 或 macOS 上安装 rustup	6
		在 Windows 上安装 rustup	7
		更新和卸载	7
		故障排除（Troubleshooting）	7
		本地文档	8
	1.2. Hello, World!	8
		创建项目目录	8
		编写并运行 Rust 程序	9
		分析这个 Rust 程序	10
		编译和运行是彼此独立的步骤	10
	1.3. Hello, Cargo!	11
		使用 Cargo 创建项目	12
		构建并运行 Cargo 项目	13
		发布（release）构建	14
		把 Cargo 当作习惯	15
	1.4. 总结	15
2. 编写 猜猜看 游戏	15
	2.1. 准备一个新项目	15
	2.2. 处理一次猜测	16
		使用变量储存值	17
		使用 Result 类型来处理潜在的错误	19
		使用 println! 占位符打印值	20
		测试第一部分代码	20
	2.3. 生成一个秘密数字	20
		使用 crate 来增加更多功能	20
		生成一个随机数	23
	2.4. 比较猜测的数字和秘密数字	24
	2.5. 使用循环来允许多次猜测	27
		猜测正确后退出	28
		处理无效输入	28
	2.6. 总结	31
3. 常见编程概念	31
	3.1. 变量和可变性	32
		变量和常量的区别	34
		隐藏（Shadowing）	34
	3.2. 数据类型	36
		标量类型	36
		复合类型	39
	3.3. 函数	42
		函数参数	43
		包含语句和表达式的函数体	44
		具有返回值的函数	46
	3.4. 注释	48
	3.5. 控制流	49
		if 表达式	49
		使用循环重复执行	53
	3.6. 总结	56
4. 认识所有权	56
	4.1. 什么是所有权？	57
		所有权规则	58
		变量作用域	58
		String 类型	59
		内存与分配	59
		所有权与函数	65
		返回值与作用域	65
	4.2. 引用与借用	67
		可变引用	69
		悬垂引用（Dangling References）	71
		引用的规则	73
	4.3. Slice 类型	73
		字符串 slice	75
		其他类型的 slice	79
	4.4. 总结	79
5. 使用结构体组织相关联的数据	80
	5.1. 定义并实例化结构体	80
		变量与字段同名时的字段初始化简写语法	82
		使用结构体更新语法从其他实例创建实例	82
		使用没有命名字段的元组结构体来创建不同的类型	83
		没有任何字段的类单元结构体	83
	5.2. 一个使用结构体的示例程序	84
		使用元组重构	85
		使用结构体重构：赋予更多意义	86
		通过派生 trait 增加实用功能	87
	5.3. 方法语法	89
		定义方法	89
		带有更多参数的方法	91
		关联函数	92
		多个 impl 块	92
	5.4. 总结	92
6. 枚举和模式匹配	93
	6.1. 定义枚举	93
		枚举值	94
		Option 枚举和其相对于空值的优势	97
	6.2. match 控制流运算符	99
		绑定值的模式	101
		匹配 Option<T>	102
		匹配是穷尽的	103
		_ 通配符	104
	6.3. if let 简单控制流	104
	6.4. 总结	105
7. 使用包、Crate和模块管理不断增长的项目	106
	7.1. 包和 crate	106
	7.2. 定义模块来控制作用域与私有性	108
	7.3. 路径用于引用模块树中的项	109
		使用 pub 关键字暴露路径	111
		使用 super 起始的相对路径	113
		创建公有的结构体和枚举	114
	7.4. 使用 use 关键字将名称引入作用域	116
		创建惯用的 use 路径	117
		使用 as 关键字提供新的名称	119
		使用 pub use 重导出名称	119
		使用外部包	120
		嵌套路径来消除大量的 use 行	121
		通过 glob 运算符将所有的公有定义引入作用域	122
	7.5. 将模块分割进不同文件	122
	7.6. 总结	124
8. 常见集合	124
	8.1. vector 用来储存一系列的值	124
		新建 vector	124
		更新 vector	125
		丢弃 vector 时也会丢弃其所有元素	125
		读取 vector 的元素	126
		遍历 vector 中的元素	128
		使用枚举来储存多种类型	128
	8.2. 使用字符串存储 UTF-8 编码的文本	129
		什么是字符串？	129
		新建字符串	130
		更新字符串	131
		索引字符串	133
		字符串 slice	135
		遍历字符串的方法	136
		字符串并不简单	136
	8.3. 哈希 map 储存键值对	137
		新建一个哈希 map	137
		哈希 map 和所有权	138
		访问哈希 map 中的值	138
		更新哈希 map	139
		哈希函数	141
	8.4. 总结	141
9. 错误处理	142
	9.1. panic! 与不可恢复的错误	142
		使用 panic! 的 backtrace	143
	9.2. Result 与可恢复的错误	146
		匹配不同的错误	148
		失败时 panic 的简写：unwrap 和 expect	149
		传播错误	150
		传播错误的简写：? 运算符	152
		? 运算符可被用于返回 Result 的函数	153
	9.3. panic! 还是不 panic!	154
		示例、代码原型和测试都非常适合 panic	155
		当我们比编译器知道更多的情况	155
		错误处理指导原则	155
		创建自定义类型进行有效性验证	156
	9.4. 总结	158
10. 泛型、trait 和生命周期	158
	10.1. 提取函数来减少重复	159
	10.2. 泛型数据类型	161
		在函数定义中使用泛型	162
		结构体定义中的泛型	164
		枚举定义中的泛型	165
		方法定义中的泛型	166
		泛型代码的性能	168
	10.3. trait：定义共享的行为	169
		定义 trait	169
		为类型实现 trait	170
		默认实现	172
		trait 作为参数	174
		返回实现了 trait 的类型	175
		使用 trait bounds 来修复 largest 函数	176
		使用 trait bound 有条件地实现方法	178
	10.4. 生命周期与引用有效性	180
		生命周期避免了悬垂引用	180
		函数中的泛型生命周期	182
		生命周期注解语法	183
		函数签名中的生命周期注解	184
		深入理解生命周期	186
		结构体定义中的生命周期注解	187
		生命周期省略（Lifetime Elision）	188
		方法定义中的生命周期注解	190
		静态生命周期	190
		结合泛型类型参数、trait bounds 和生命周期	191
	10.5. 总结	191
11. 编写自动化测试	192
	11.1. 如何编写测试	192
		测试函数剖析	193
		使用 assert! 宏来检查结果	196
		使用 assert_eq! 和 assert_ne! 宏来测试相等	198
		自定义失败信息	200
		使用 should_panic 检查 panic	202
		将 Result<T, E> 用于测试	205
	11.2. 控制测试如何运行	206
		并行或连续的运行测试	206
		显示函数输出	206
		通过指定名字来运行部分测试	208
		忽略某些测试	210
	11.3. 测试的组织结构	211
		单元测试	211
		集成测试	213
	11.4. 总结	217
12. 一个 I/O 项目：构建一个命令行程序	217
	12.1. 接受命令行参数	218
		读取参数值	218
		将参数值保存进变量	219
	12.2. 读取文件	220
	12.3. 重构改进模块性和错误处理	222
		二进制项目的关注分离	223
		提取参数解析器	223
		组合配置值	224
		创建一个 Config 的构造函数	226
		修复错误处理	226
		从 main 提取逻辑	229
		将代码拆分到库 crate	232
	12.4. 采用测试驱动开发完善库的功能	233
		编写失败测试	234
		编写使测试通过的代码	236
	12.5. 处理环境变量	238
		编写一个大小写不敏感 search 函数的失败测试	239
		实现 search_case_insensitive 函数	240
	12.6. 将错误信息输出到标准错误而不是标准输出	243
		检查错误应该写入何处	243
		将错误打印到标准错误	244
	12.7. 总结	245
13. Rust 中的函数式语言功能：迭代器与闭包	245
	13.1. 闭包：可以捕获环境的匿名函数	245
		使用闭包创建行为的抽象	246
		闭包类型推断和注解	250
		使用带有泛型和 Fn trait 的闭包	252
		Cacher 实现的限制	254
		闭包会捕获其环境	255
	13.2. 使用迭代器处理元素序列	258
		Iterator trait 和 next 方法	258
		消费迭代器的方法	259
		产生其他迭代器的方法	260
		使用闭包获取环境	261
		实现 Iterator trait 来创建自定义迭代器	262
	13.3. 改进 I/O 项目	265
		使用迭代器并去掉 clone	265
		使用迭代器适配器来使代码更简明	267
	13.4. 性能对比：循环 VS 迭代器	268
	13.5. 总结	270
14. 进一步认识 Cargo 和 Crates.io	270
	14.1. 采用发布配置自定义构建	270
	14.2. 将 crate 发布到 Crates.io	271
		编写有用的文档注释	272
		使用 pub use 导出合适的公有 API	275
		创建 Crates.io 账号	278
		发布新 crate 之前	279
		发布到 Crates.io	280
		发布现存 crate 的新版本	281
		使用 cargo yank 从 Crates.io 撤回版本	281
	14.3. Cargo 工作空间	281
		创建工作空间	281
		在工作空间中创建第二个 crate	282
	14.4. 使用 cargo install 从 Crates.io 安装二进制文件	287
	14.5. Cargo 自定义扩展命令	287
	14.6. 总结	288
15. 智能指针	288
	15.1. 使用Box <T>指向堆上的数据	289
		使用 Box<T> 在堆上储存数据	289
		Box 允许创建递归类型	290
		计算非递归类型的大小	291
		使用 Box<T> 给递归类型一个已知的大小	292
	15.2. 通过 Deref trait 将智能指针当作常规引用处理	294
		通过解引用运算符追踪指针的值	294
		像引用一样使用 Box<T>	295
		自定义智能指针	295
		通过实现 Deref trait 将某类型像引用一样处理	296
		函数和方法的隐式解引用强制多态	297
		解引用强制多态如何与可变性交互	299
	15.3. 使用 Drop Trait 运行清理代码	299
	15.4. Rc<T> 引用计数智能指针	302
		使用 Rc<T> 共享数据	302
		克隆 Rc<T> 会增加引用计数	304
	15.5. RefCell<T> 和内部可变性模式	305
		通过 RefCell<T> 在运行时检查借用规则	306
		内部可变性：不可变值的可变借用	307
		RefCell<T> 在运行时记录借用	311
		结合 Rc<T> 和 RefCell<T> 来拥有多个可变数据所有者	311
	15.6. 引用循环与内存泄漏	313
		制造引用循环	313
		避免引用循环：将 Rc<T> 变为 Weak<T>	316
	15.7. 总结	321
16. 无畏并发	321
	16.1. 使用线程同时运行代码	322
		使用 spawn 创建新线程	323
		线程与 move 闭包	326
	16.2. 使用消息传递在线程间传送数据	328
		通道与所有权转移	331
		发送多个值并观察接收者的等待	332
		通过克隆发送者来创建多个生产者	333
	16.3. 共享状态并发	335
		互斥器一次只允许一个线程访问数据	335
		Mutex<T>的 API	336
		RefCell<T>/Rc<T> 与 Mutex<T>/Arc<T> 的相似性	340
	16.4. 使用 Sync 和 Send trait 的可扩展并发	341
		通过 Send 允许在线程间转移所有权	341
		Sync 允许多线程访问	341
		手动实现 Send 和 Sync 是不安全的	341
	16.5. 总结	342
17. Rust 的面向对象特性	342
	17.1. 面向对象语言的特征	342
		对象包含数据和行为	343
		封装隐藏了实现细节	343
	17.2. 继承，作为类型系统与代码共享	345
	17.3. 为使用不同类型的值而设计的 trait 对象	345
		定义通用行为的 trait	346
		实现 trait	348
		trait 对象执行动态分发	351
		Trait 对象要求对象安全	351
	17.4. 面向对象设计模式的实现	352
		定义 Post 并新建一个草案状态的实例	354
		存放博文内容的文本	354
		确保博文草案的内容是空的	355
		请求审核博文来改变其状态	355
		增加改变 content 行为的 approve 方法	357
		状态模式的权衡取舍	360
	17.5. 总结	364
18. 模式用来匹配值的结构	364
	18.1. 所有可能会用到模式的位置	365
		match 分支	365
		if let 条件表达式	366
		while let 条件循环	367
		for 循环	367
		let 语句	368
		函数参数	369
	18.2. Refutability（可反驳性）: 模式是否会匹配失效	370
	18.3. 所有的模式语法	371
		匹配字面值	371
		匹配命名变量	372
		多个模式	373
		通过 ..= 匹配值的范围	373
		解构并分解值	374
		忽略模式中的值	378
		匹配守卫提供的额外条件	382
		@ 绑定	384
	18.4. 总结	384
19. 高级特征	385
	19.1. 不安全 Rust	385
		不安全的超级力量	386
		解引用裸指针	386
		调用不安全函数或方法	388
		访问或修改可变静态变量	392
		实现不安全 trait	393
		何时使用不安全代码	393
	19.2. 高级 trait	393
		关联类型在 trait 定义中指定占位符类型	394
		默认泛型类型参数和运算符重载	395
		完全限定语法与消歧义：调用相同名称的方法	397
		父 trait 用于在另一个 trait 中使用某 trait 的功能	401
		newtype 模式用以在外部类型上实现外部 trait	402
	19.3. 高级类型	403
		为了类型安全和抽象而使用 newtype 模式	404
		类型别名用来创建类型同义词	404
		从不返回的 never type	406
		动态大小类型和 Sized trait	408
	19.4. 高级函数与闭包	409
		函数指针	409
		返回闭包	411
	19.5. 宏	412
		宏和函数的区别	412
		使用 macro_rules! 的声明宏用于通用元编程	413
		用于从属性生成代码的过程宏	414
		如何编写自定义 derive 宏	415
		类属性宏	420
		类函数宏	420
	19.6. 总结	421
20. 最后的项目: 构建多线程 web server	421
	20.1. 构建单线程 web server	422
		监听 TCP 连接	422
		读取请求	424
		编写响应	426
		返回真正的 HTML	427
		验证请求并有选择的进行响应	428
		少量代码重构	430
	20.2. 将单线程 server 变为多线程 server	431
		在当前 server 实现中模拟慢请求	431
		使用线程池改善吞吐量	432
	20.3. 优雅停机与清理	449
		为 ThreadPool 实现 Drop Trait	450
		向线程发送信号使其停止接收任务	452
	20.4. 总结	459
21. 附录	459
	21.1. 附录 A： 关键字	459
		目前正在使用的关键字	459
		保留做将来使用的关键字	460
		原始标识符	461
	21.2. 附录 B：运算符与符号	462
		运算符	462
		非运算符符号	464
	21.3. 附录 C：可派生的 trait	467
		用于程序员输出的 Debug	468
	21.4. 等值比较的 PartialEq 和 Eq	468
	21.5. 次序比较的 PartialOrd 和 Ord	469
	21.6. 复制值的 Clone 和 Copy	469
	21.7. 固定大小的值到值映射的 Hash	470
	21.8. 默认值的 Default	470
	21.9. 附录 D：实用开发工具	470
	21.10. 通过 rustfmt 自动格式化	470
	21.11. 通过 rustfix 修复代码	471
	21.12. 通过 clippy 提供更多 lint 功能	472
	21.13. 使用 Rust Language Server 的 IDE 集成	473
	21.14. 附录 E：版本	473
	21.15. 附录 F：本书译本	474
	21.16. 附录 G：Rust 是如何开发的与 “Nightly Rust”	475
		无停滞稳定	475
		Choo, Choo!（开车啦，逃）发布通道和发布时刻表（Riding the Trains）	476
		不稳定功能	477
		Rustup 和 Rust Nightly 的职责	477
		RFC 过程和团队	478
