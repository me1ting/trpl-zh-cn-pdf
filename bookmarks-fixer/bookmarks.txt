[{"title":"Rust 程序设计语言","page_num":1,"level":1},{"title":"前言","page_num":1,"level":1},{"title":"介绍","page_num":2,"level":1},{"title":"谁会使用 Rust","page_num":2,"level":2},{"title":"开发者团队","page_num":3,"level":3},{"title":"学生","page_num":3,"level":3},{"title":"公司","page_num":3,"level":3},{"title":"开源开发者","page_num":3,"level":3},{"title":"重视速度和稳定性的开发者","page_num":3,"level":3},{"title":"本书是写给谁的","page_num":4,"level":2},{"title":"如何阅读本书","page_num":4,"level":2},{"title":"源代码","page_num":5,"level":2},{"title":"入门指南","page_num":6,"level":1},{"title":"安装","page_num":6,"level":2},{"title":"在 Linux 或 macOS 上安装 rustup","page_num":7,"level":3},{"title":"在 Windows 上安装 rustup","page_num":7,"level":3},{"title":"更新和卸载","page_num":7,"level":3},{"title":"故障排除（Troubleshooting）","page_num":8,"level":3},{"title":"本地文档","page_num":8,"level":3},{"title":"Hello, World!","page_num":8,"level":2},{"title":"创建项目目录","page_num":9,"level":3},{"title":"编写并运行 Rust 程序","page_num":9,"level":3},{"title":"分析这个 Rust 程序","page_num":10,"level":3},{"title":"编译和运行是彼此独立的步骤","page_num":11,"level":3},{"title":"Hello, Cargo!","page_num":12,"level":2},{"title":"使用 Cargo 创建项目","page_num":12,"level":3},{"title":"构建并运行 Cargo 项目","page_num":14,"level":3},{"title":"发布（release）构建","page_num":15,"level":3},{"title":"把 Cargo 当作习惯","page_num":15,"level":3},{"title":"总结","page_num":16,"level":2},{"title":"编写 猜猜看 游戏","page_num":16,"level":1},{"title":"准备一个新项目","page_num":16,"level":2},{"title":"处理一次猜测","page_num":17,"level":2},{"title":"使用变量储存值","page_num":18,"level":3},{"title":"使用 Result 类型来处理潜在的错误","page_num":20,"level":3},{"title":"使用 println! 占位符打印值","page_num":21,"level":3},{"title":"测试第一部分代码","page_num":21,"level":3},{"title":"生成一个秘密数字","page_num":21,"level":2},{"title":"使用 crate 来增加更多功能","page_num":21,"level":3},{"title":"生成一个随机数","page_num":24,"level":3},{"title":"比较猜测的数字和秘密数字","page_num":25,"level":2},{"title":"使用循环来允许多次猜测","page_num":28,"level":2},{"title":"猜测正确后退出","page_num":29,"level":3},{"title":"处理无效输入","page_num":30,"level":3},{"title":"总结","page_num":32,"level":2},{"title":"常见编程概念","page_num":32,"level":1},{"title":"变量和可变性","page_num":33,"level":2},{"title":"变量和常量的区别","page_num":34,"level":3},{"title":"隐藏（Shadowing）","page_num":35,"level":3},{"title":"数据类型","page_num":36,"level":2},{"title":"标量类型","page_num":37,"level":3},{"title":"复合类型","page_num":40,"level":3},{"title":"函数","page_num":43,"level":2},{"title":"函数参数","page_num":44,"level":3},{"title":"包含语句和表达式的函数体","page_num":45,"level":3},{"title":"具有返回值的函数","page_num":47,"level":3},{"title":"注释","page_num":49,"level":2},{"title":"控制流","page_num":50,"level":2},{"title":"if 表达式","page_num":50,"level":3},{"title":"使用循环重复执行","page_num":54,"level":3},{"title":"总结","page_num":58,"level":2},{"title":"认识所有权","page_num":58,"level":1},{"title":"什么是所有权？","page_num":58,"level":2},{"title":"所有权规则","page_num":59,"level":3},{"title":"变量作用域","page_num":60,"level":3},{"title":"String 类型","page_num":60,"level":3},{"title":"内存与分配","page_num":61,"level":3},{"title":"所有权与函数","page_num":67,"level":3},{"title":"返回值与作用域","page_num":67,"level":3},{"title":"引用与借用","page_num":69,"level":2},{"title":"可变引用","page_num":71,"level":3},{"title":"悬垂引用（Dangling References）","page_num":73,"level":3},{"title":"引用的规则","page_num":75,"level":3},{"title":"Slice 类型","page_num":75,"level":2},{"title":"字符串 slice","page_num":77,"level":3},{"title":"其他类型的 slice","page_num":81,"level":3},{"title":"总结","page_num":82,"level":2},{"title":"使用结构体组织相关联的数据","page_num":82,"level":1},{"title":"定义并实例化结构体","page_num":82,"level":2},{"title":"变量与字段同名时的字段初始化简写语法","page_num":84,"level":3},{"title":"使用结构体更新语法从其他实例创建实例","page_num":84,"level":3},{"title":"使用没有命名字段的元组结构体来创建不同的类型","page_num":85,"level":3},{"title":"没有任何字段的类单元结构体","page_num":86,"level":3},{"title":"一个使用结构体的示例程序","page_num":87,"level":2},{"title":"使用元组重构","page_num":88,"level":3},{"title":"使用结构体重构：赋予更多意义","page_num":88,"level":3},{"title":"通过派生 trait 增加实用功能","page_num":89,"level":3},{"title":"方法语法","page_num":91,"level":2},{"title":"定义方法","page_num":91,"level":3},{"title":"带有更多参数的方法","page_num":93,"level":3},{"title":"关联函数","page_num":94,"level":3},{"title":"多个 impl 块","page_num":94,"level":3},{"title":"总结","page_num":95,"level":2},{"title":"枚举和模式匹配","page_num":95,"level":1},{"title":"定义枚举","page_num":96,"level":2},{"title":"枚举值","page_num":96,"level":3},{"title":"Option 枚举和其相对于空值的优势","page_num":100,"level":3},{"title":"match 控制流运算符","page_num":102,"level":2},{"title":"绑定值的模式","page_num":103,"level":3},{"title":"匹配 Option<T>","page_num":104,"level":3},{"title":"匹配是穷尽的","page_num":105,"level":3},{"title":"_ 通配符","page_num":106,"level":3},{"title":"if let 简单控制流","page_num":107,"level":2},{"title":"总结","page_num":108,"level":2},{"title":"使用包、Crate和模块管理不断增长的项目","page_num":108,"level":1},{"title":"包和 crate","page_num":109,"level":2},{"title":"定义模块来控制作用域与私有性","page_num":110,"level":2},{"title":"路径用于引用模块树中的项","page_num":112,"level":2},{"title":"使用 pub 关键字暴露路径","page_num":114,"level":3},{"title":"使用 super 起始的相对路径","page_num":116,"level":3},{"title":"创建公有的结构体和枚举","page_num":116,"level":3},{"title":"使用 use 关键字将名称引入作用域","page_num":118,"level":2},{"title":"创建惯用的 use 路径","page_num":119,"level":3},{"title":"使用 as 关键字提供新的名称","page_num":121,"level":3},{"title":"使用 pub use 重导出名称","page_num":121,"level":3},{"title":"使用外部包","page_num":122,"level":3},{"title":"嵌套路径来消除大量的 use 行","page_num":123,"level":3},{"title":"通过 glob 运算符将所有的公有定义引入作用域","page_num":124,"level":3},{"title":"将模块分割进不同文件","page_num":124,"level":2},{"title":"总结","page_num":126,"level":2},{"title":"常见集合","page_num":126,"level":1},{"title":"vector 用来储存一系列的值","page_num":126,"level":2},{"title":"新建 vector","page_num":127,"level":3},{"title":"更新 vector","page_num":127,"level":3},{"title":"丢弃 vector 时也会丢弃其所有元素","page_num":128,"level":3},{"title":"读取 vector 的元素","page_num":128,"level":3},{"title":"遍历 vector 中的元素","page_num":130,"level":3},{"title":"使用枚举来储存多种类型","page_num":130,"level":3},{"title":"使用字符串存储 UTF-8 编码的文本","page_num":131,"level":2},{"title":"什么是字符串？","page_num":132,"level":3},{"title":"新建字符串","page_num":132,"level":3},{"title":"更新字符串","page_num":133,"level":3},{"title":"索引字符串","page_num":135,"level":3},{"title":"字符串 slice","page_num":137,"level":3},{"title":"遍历字符串的方法","page_num":138,"level":3},{"title":"字符串并不简单","page_num":138,"level":3},{"title":"哈希 map 储存键值对","page_num":139,"level":2},{"title":"新建一个哈希 map","page_num":139,"level":3},{"title":"哈希 map 和所有权","page_num":140,"level":3},{"title":"访问哈希 map 中的值","page_num":141,"level":3},{"title":"更新哈希 map","page_num":141,"level":3},{"title":"哈希函数","page_num":143,"level":3},{"title":"总结","page_num":143,"level":2},{"title":"错误处理","page_num":144,"level":1},{"title":"panic! 与不可恢复的错误","page_num":144,"level":2},{"title":"使用 panic! 的 backtrace","page_num":145,"level":3},{"title":"Result 与可恢复的错误","page_num":148,"level":2},{"title":"匹配不同的错误","page_num":150,"level":3},{"title":"失败时 panic 的简写：unwrap 和 expect","page_num":151,"level":3},{"title":"传播错误","page_num":152,"level":3},{"title":"传播错误的简写：? 运算符","page_num":153,"level":3},{"title":"? 运算符可被用于返回 Result 的函数","page_num":155,"level":3},{"title":"panic! 还是不 panic!","page_num":156,"level":2},{"title":"示例、代码原型和测试都非常适合 panic","page_num":156,"level":3},{"title":"当我们比编译器知道更多的情况","page_num":157,"level":3},{"title":"错误处理指导原则","page_num":157,"level":3},{"title":"创建自定义类型进行有效性验证","page_num":158,"level":3},{"title":"总结","page_num":160,"level":2},{"title":"泛型、trait 和生命周期","page_num":160,"level":1},{"title":"提取函数来减少重复","page_num":160,"level":2},{"title":"泛型数据类型","page_num":163,"level":2},{"title":"在函数定义中使用泛型","page_num":163,"level":3},{"title":"结构体定义中的泛型","page_num":165,"level":3},{"title":"枚举定义中的泛型","page_num":167,"level":3},{"title":"方法定义中的泛型","page_num":168,"level":3},{"title":"泛型代码的性能","page_num":170,"level":3},{"title":"trait：定义共享的行为","page_num":171,"level":2},{"title":"定义 trait","page_num":171,"level":3},{"title":"为类型实现 trait","page_num":172,"level":3},{"title":"默认实现","page_num":173,"level":3},{"title":"trait 作为参数","page_num":175,"level":3},{"title":"返回实现了 trait 的类型","page_num":177,"level":3},{"title":"使用 trait bounds 来修复 largest 函数","page_num":177,"level":3},{"title":"使用 trait bound 有条件地实现方法","page_num":179,"level":3},{"title":"生命周期与引用有效性","page_num":181,"level":2},{"title":"生命周期避免了悬垂引用","page_num":181,"level":3},{"title":"函数中的泛型生命周期","page_num":183,"level":3},{"title":"生命周期注解语法","page_num":184,"level":3},{"title":"函数签名中的生命周期注解","page_num":185,"level":3},{"title":"深入理解生命周期","page_num":187,"level":3},{"title":"结构体定义中的生命周期注解","page_num":188,"level":3},{"title":"生命周期省略（Lifetime Elision）","page_num":189,"level":3},{"title":"方法定义中的生命周期注解","page_num":191,"level":3},{"title":"静态生命周期","page_num":192,"level":3},{"title":"结合泛型类型参数、trait bounds 和生命周期","page_num":192,"level":3},{"title":"总结","page_num":192,"level":2},{"title":"编写自动化测试","page_num":193,"level":1},{"title":"如何编写测试","page_num":193,"level":2},{"title":"测试函数剖析","page_num":194,"level":3},{"title":"使用 assert! 宏来检查结果","page_num":197,"level":3},{"title":"使用 assert_eq! 和 assert_ne! 宏来测试相等","page_num":199,"level":3},{"title":"自定义失败信息","page_num":201,"level":3},{"title":"使用 should_panic 检查 panic","page_num":203,"level":3},{"title":"将 Result<T, E> 用于测试","page_num":206,"level":3},{"title":"控制测试如何运行","page_num":207,"level":2},{"title":"并行或连续的运行测试","page_num":207,"level":3},{"title":"显示函数输出","page_num":208,"level":3},{"title":"通过指定名字来运行部分测试","page_num":209,"level":3},{"title":"忽略某些测试","page_num":211,"level":3},{"title":"测试的组织结构","page_num":212,"level":2},{"title":"单元测试","page_num":212,"level":3},{"title":"集成测试","page_num":214,"level":3},{"title":"总结","page_num":217,"level":2},{"title":"一个 I/O 项目：构建一个命令行程序","page_num":218,"level":1},{"title":"接受命令行参数","page_num":218,"level":2},{"title":"读取参数值","page_num":219,"level":3},{"title":"将参数值保存进变量","page_num":220,"level":3},{"title":"读取文件","page_num":221,"level":2},{"title":"重构改进模块性和错误处理","page_num":223,"level":2},{"title":"二进制项目的关注分离","page_num":223,"level":3},{"title":"提取参数解析器","page_num":224,"level":3},{"title":"组合配置值","page_num":224,"level":3},{"title":"创建一个 Config 的构造函数","page_num":226,"level":3},{"title":"修复错误处理","page_num":227,"level":3},{"title":"从 main 提取逻辑","page_num":230,"level":3},{"title":"将代码拆分到库 crate","page_num":232,"level":3},{"title":"采用测试驱动开发完善库的功能","page_num":233,"level":2},{"title":"编写失败测试","page_num":234,"level":3},{"title":"编写使测试通过的代码","page_num":236,"level":3},{"title":"处理环境变量","page_num":239,"level":2},{"title":"编写一个大小写不敏感 search 函数的失败测试","page_num":239,"level":3},{"title":"实现 search_case_insensitive 函数","page_num":241,"level":3},{"title":"将错误信息输出到标准错误而不是标准输出","page_num":244,"level":2},{"title":"检查错误应该写入何处","page_num":244,"level":3},{"title":"将错误打印到标准错误","page_num":245,"level":3},{"title":"总结","page_num":246,"level":2},{"title":"Rust 中的函数式语言功能：迭代器与闭包","page_num":246,"level":1},{"title":"闭包：可以捕获环境的匿名函数","page_num":246,"level":2},{"title":"使用闭包创建行为的抽象","page_num":247,"level":3},{"title":"闭包类型推断和注解","page_num":251,"level":3},{"title":"使用带有泛型和 Fn trait 的闭包","page_num":253,"level":3},{"title":"Cacher 实现的限制","page_num":255,"level":3},{"title":"闭包会捕获其环境","page_num":256,"level":3},{"title":"使用迭代器处理元素序列","page_num":259,"level":2},{"title":"Iterator trait 和 next 方法","page_num":260,"level":3},{"title":"消费迭代器的方法","page_num":261,"level":3},{"title":"产生其他迭代器的方法","page_num":261,"level":3},{"title":"使用闭包获取环境","page_num":262,"level":3},{"title":"实现 Iterator trait 来创建自定义迭代器","page_num":264,"level":3},{"title":"改进 I/O 项目","page_num":266,"level":2},{"title":"使用迭代器并去掉 clone","page_num":266,"level":3},{"title":"使用迭代器适配器来使代码更简明","page_num":268,"level":3},{"title":"性能对比：循环 VS 迭代器","page_num":269,"level":2},{"title":"总结","page_num":271,"level":2},{"title":"进一步认识 Cargo 和 Crates.io","page_num":271,"level":1},{"title":"采用发布配置自定义构建","page_num":272,"level":2},{"title":"将 crate 发布到 Crates.io","page_num":273,"level":2},{"title":"编写有用的文档注释","page_num":273,"level":3},{"title":"使用 pub use 导出合适的公有 API","page_num":276,"level":3},{"title":"创建 Crates.io 账号","page_num":280,"level":3},{"title":"发布新 crate 之前","page_num":280,"level":3},{"title":"发布到 Crates.io","page_num":281,"level":3},{"title":"发布现存 crate 的新版本","page_num":282,"level":3},{"title":"使用 cargo yank 从 Crates.io 撤回版本","page_num":282,"level":3},{"title":"Cargo 工作空间","page_num":283,"level":2},{"title":"创建工作空间","page_num":283,"level":3},{"title":"在工作空间中创建第二个 crate","page_num":284,"level":3},{"title":"使用 cargo install 从 Crates.io 安装二进制文件","page_num":288,"level":2},{"title":"Cargo 自定义扩展命令","page_num":289,"level":2},{"title":"总结","page_num":289,"level":2},{"title":"智能指针","page_num":289,"level":1},{"title":"使用Box <T>指向堆上的数据","page_num":290,"level":2},{"title":"使用 Box<T> 在堆上储存数据","page_num":291,"level":3},{"title":"Box 允许创建递归类型","page_num":291,"level":3},{"title":"计算非递归类型的大小","page_num":293,"level":3},{"title":"使用 Box<T> 给递归类型一个已知的大小","page_num":294,"level":3},{"title":"通过 Deref trait 将智能指针当作常规引用处理","page_num":295,"level":2},{"title":"通过解引用运算符追踪指针的值","page_num":296,"level":3},{"title":"像引用一样使用 Box<T>","page_num":297,"level":3},{"title":"自定义智能指针","page_num":297,"level":3},{"title":"通过实现 Deref trait 将某类型像引用一样处理","page_num":298,"level":3},{"title":"函数和方法的隐式解引用强制多态","page_num":299,"level":3},{"title":"解引用强制多态如何与可变性交互","page_num":300,"level":3},{"title":"使用 Drop Trait 运行清理代码","page_num":301,"level":2},{"title":"Rc<T> 引用计数智能指针","page_num":304,"level":2},{"title":"使用 Rc<T> 共享数据","page_num":304,"level":3},{"title":"克隆 Rc<T> 会增加引用计数","page_num":306,"level":3},{"title":"RefCell<T> 和内部可变性模式","page_num":307,"level":2},{"title":"通过 RefCell<T> 在运行时检查借用规则","page_num":308,"level":3},{"title":"内部可变性：不可变值的可变借用","page_num":309,"level":3},{"title":"RefCell<T> 在运行时记录借用","page_num":313,"level":3},{"title":"结合 Rc<T> 和 RefCell<T> 来拥有多个可变数据所有者","page_num":314,"level":3},{"title":"引用循环与内存泄漏","page_num":315,"level":2},{"title":"制造引用循环","page_num":315,"level":3},{"title":"避免引用循环：将 Rc<T> 变为 Weak<T>","page_num":318,"level":3},{"title":"总结","page_num":323,"level":2},{"title":"无畏并发","page_num":323,"level":1},{"title":"使用线程同时运行代码","page_num":324,"level":2},{"title":"使用 spawn 创建新线程","page_num":325,"level":3},{"title":"线程与 move 闭包","page_num":328,"level":3},{"title":"使用消息传递在线程间传送数据","page_num":330,"level":2},{"title":"通道与所有权转移","page_num":333,"level":3},{"title":"发送多个值并观察接收者的等待","page_num":334,"level":3},{"title":"通过克隆发送者来创建多个生产者","page_num":335,"level":3},{"title":"共享状态并发","page_num":336,"level":2},{"title":"互斥器一次只允许一个线程访问数据","page_num":337,"level":3},{"title":"Mutex<T>的 API","page_num":337,"level":3},{"title":"RefCell<T>/Rc<T> 与 Mutex<T>/Arc<T> 的相似性","page_num":342,"level":3},{"title":"使用 Sync 和 Send trait 的可扩展并发","page_num":342,"level":2},{"title":"通过 Send 允许在线程间转移所有权","page_num":342,"level":3},{"title":"Sync 允许多线程访问","page_num":343,"level":3},{"title":"手动实现 Send 和 Sync 是不安全的","page_num":343,"level":3},{"title":"总结","page_num":343,"level":2},{"title":"Rust 的面向对象特性","page_num":343,"level":1},{"title":"面向对象语言的特征","page_num":344,"level":2},{"title":"对象包含数据和行为","page_num":344,"level":3},{"title":"封装隐藏了实现细节","page_num":345,"level":3},{"title":"继承，作为类型系统与代码共享","page_num":346,"level":2},{"title":"为使用不同类型的值而设计的 trait 对象","page_num":347,"level":2},{"title":"定义通用行为的 trait","page_num":348,"level":3},{"title":"实现 trait","page_num":349,"level":3},{"title":"trait 对象执行动态分发","page_num":352,"level":3},{"title":"Trait 对象要求对象安全","page_num":352,"level":3},{"title":"面向对象设计模式的实现","page_num":353,"level":2},{"title":"定义 Post 并新建一个草案状态的实例","page_num":355,"level":3},{"title":"存放博文内容的文本","page_num":356,"level":3},{"title":"确保博文草案的内容是空的","page_num":356,"level":3},{"title":"请求审核博文来改变其状态","page_num":357,"level":3},{"title":"增加改变 content 行为的 approve 方法","page_num":358,"level":3},{"title":"状态模式的权衡取舍","page_num":361,"level":3},{"title":"总结","page_num":364,"level":2},{"title":"模式用来匹配值的结构","page_num":365,"level":1},{"title":"所有可能会用到模式的位置","page_num":365,"level":2},{"title":"match 分支","page_num":366,"level":3},{"title":"if let 条件表达式","page_num":366,"level":3},{"title":"while let 条件循环","page_num":367,"level":3},{"title":"for 循环","page_num":368,"level":3},{"title":"let 语句","page_num":368,"level":3},{"title":"函数参数","page_num":369,"level":3},{"title":"Refutability（可反驳性）: 模式是否会匹配失效","page_num":370,"level":2},{"title":"所有的模式语法","page_num":372,"level":2},{"title":"匹配字面值","page_num":372,"level":3},{"title":"匹配命名变量","page_num":372,"level":3},{"title":"多个模式","page_num":373,"level":3},{"title":"通过 ..= 匹配值的范围","page_num":374,"level":3},{"title":"解构并分解值","page_num":374,"level":3},{"title":"忽略模式中的值","page_num":378,"level":3},{"title":"匹配守卫提供的额外条件","page_num":383,"level":3},{"title":"@ 绑定","page_num":384,"level":3},{"title":"总结","page_num":385,"level":2},{"title":"高级特征","page_num":385,"level":1},{"title":"不安全 Rust","page_num":386,"level":2},{"title":"不安全的超级力量","page_num":386,"level":3},{"title":"解引用裸指针","page_num":387,"level":3},{"title":"调用不安全函数或方法","page_num":389,"level":3},{"title":"访问或修改可变静态变量","page_num":393,"level":3},{"title":"实现不安全 trait","page_num":394,"level":3},{"title":"何时使用不安全代码","page_num":394,"level":3},{"title":"高级 trait","page_num":395,"level":2},{"title":"关联类型在 trait 定义中指定占位符类型","page_num":395,"level":3},{"title":"默认泛型类型参数和运算符重载","page_num":396,"level":3},{"title":"完全限定语法与消歧义：调用相同名称的方法","page_num":398,"level":3},{"title":"父 trait 用于在另一个 trait 中使用某 trait 的功能","page_num":402,"level":3},{"title":"newtype 模式用以在外部类型上实现外部 trait","page_num":403,"level":3},{"title":"高级类型","page_num":404,"level":2},{"title":"为了类型安全和抽象而使用 newtype 模式","page_num":405,"level":3},{"title":"类型别名用来创建类型同义词","page_num":405,"level":3},{"title":"从不返回的 never type","page_num":407,"level":3},{"title":"动态大小类型和 Sized trait","page_num":409,"level":3},{"title":"高级函数与闭包","page_num":410,"level":2},{"title":"函数指针","page_num":410,"level":3},{"title":"返回闭包","page_num":412,"level":3},{"title":"宏","page_num":413,"level":2},{"title":"宏和函数的区别","page_num":413,"level":3},{"title":"使用 macro_rules! 的声明宏用于通用元编程","page_num":414,"level":3},{"title":"用于从属性生成代码的过程宏","page_num":415,"level":3},{"title":"如何编写自定义 derive 宏","page_num":416,"level":3},{"title":"类属性宏","page_num":421,"level":3},{"title":"类函数宏","page_num":421,"level":3},{"title":"总结","page_num":422,"level":2},{"title":"最后的项目: 构建多线程 web server","page_num":422,"level":1},{"title":"构建单线程 web server","page_num":423,"level":2},{"title":"监听 TCP 连接","page_num":424,"level":3},{"title":"读取请求","page_num":425,"level":3},{"title":"编写响应","page_num":427,"level":3},{"title":"返回真正的 HTML","page_num":428,"level":3},{"title":"验证请求并有选择的进行响应","page_num":429,"level":3},{"title":"少量代码重构","page_num":431,"level":3},{"title":"将单线程 server 变为多线程 server","page_num":432,"level":2},{"title":"在当前 server 实现中模拟慢请求","page_num":432,"level":3},{"title":"使用线程池改善吞吐量","page_num":433,"level":3},{"title":"优雅停机与清理","page_num":449,"level":2},{"title":"为 ThreadPool 实现 Drop Trait","page_num":449,"level":3},{"title":"向线程发送信号使其停止接收任务","page_num":451,"level":3},{"title":"总结","page_num":458,"level":2},{"title":"附录","page_num":458,"level":1},{"title":"附录 A： 关键字","page_num":459,"level":2},{"title":"目前正在使用的关键字","page_num":459,"level":3},{"title":"保留做将来使用的关键字","page_num":460,"level":3},{"title":"原始标识符","page_num":460,"level":3},{"title":"附录 B：运算符与符号","page_num":461,"level":2},{"title":"运算符","page_num":462,"level":3},{"title":"非运算符符号","page_num":463,"level":3},{"title":"附录 C：可派生的 trait","page_num":467,"level":2},{"title":"用于程序员输出的 Debug","page_num":467,"level":3},{"title":"等值比较的 PartialEq 和 Eq","page_num":468,"level":2},{"title":"次序比较的 PartialOrd 和 Ord","page_num":468,"level":2},{"title":"复制值的 Clone 和 Copy","page_num":469,"level":2},{"title":"固定大小的值到值映射的 Hash","page_num":469,"level":2},{"title":"默认值的 Default","page_num":470,"level":2},{"title":"附录 D：实用开发工具","page_num":470,"level":2},{"title":"通过 rustfmt 自动格式化","page_num":470,"level":2},{"title":"通过 rustfix 修复代码","page_num":471,"level":2},{"title":"通过 clippy 提供更多 lint 功能","page_num":472,"level":2},{"title":"使用 Rust Language Server 的 IDE 集成","page_num":473,"level":2},{"title":"附录 E：版本","page_num":473,"level":2},{"title":"附录 F：本书译本","page_num":474,"level":2},{"title":"附录 G：Rust 是如何开发的与 “Nightly Rust”","page_num":475,"level":2},{"title":"无停滞稳定","page_num":475,"level":3},{"title":"Choo, Choo!（开车啦，逃）发布通道和发布时刻表（Riding the Trains）","page_num":475,"level":3},{"title":"不稳定功能","page_num":477,"level":3},{"title":"Rustup 和 Rust Nightly 的职责","page_num":477,"level":3},{"title":"RFC 过程和团队","page_num":478,"level":3}]